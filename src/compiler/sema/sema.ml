(* A collection of functions useful througout the semantic
   evaluation phase of the compiler. *)

(* The error raised by the functions in this module *)
exception Error of Span.span * string

(* Raises an error on a spanned element with a message *)
let raise_error spanned msg =
    raise (Error ((Span.span_of spanned), msg))

(* Raises an error on a spanned element with a formatted message *)
let raise_error_fmt spanned fmt =
    let msg = Printf.sprintf fmt in
    raise (Error ((Span.span_of spanned), msg))

(* Semantic types of expressions *)
type ty =
    | VoidTy
    | IntTy
    | BoolTy
    | StringTy
    | AggregateTy of string
    | ArrayTy of ty
    | FunctionTy of ty list * ty

let ty_is_void ty = 
    match ty with
    | VoidTy -> true
    | _ -> false
    
let ty_is_array ty =
    match ty with
    | ArrayTy _ -> true
    | _ -> false

let ty_is_aggregate ty =
    match ty with
    | AggregateTy _ -> true
    | _ -> false

let get_base_ty ty =
    match ty with
    | ArrayTy t -> t
    | _ -> Util.raise_bug "get_base_ty called on invalid type"

let rec ty_to_string ty =
    match ty with
    | VoidTy -> "void"
    | IntTy -> "int"
    | BoolTy -> "bool"
    | StringTy -> "string"
    | AggregateTy n -> "struct " ^ n
    | ArrayTy t -> (ty_to_string t) ^ "[]"
    | FunctionTy (args, ret) -> 
        let arg_strs = List.map ty_to_string args in
        (String.concat ", " arg_strs) ^ " -> " ^ (ty_to_string ret)  

(* state generated by the semantic analysis passes *)
module State : sig
    type t

    (* creates a new, empty sema state *)
    val empty : unit -> t
    val get_named_type : t -> string -> ty

    (* gets the type of an expression *)
    val get_expr_type : t -> Ast.expr -> ty

    (* sets the type of an expression *)
    val set_expr_type : t -> Ast.expr -> ty -> unit

    val get_escape_status : t -> Ast.ident -> bool
    val set_escape_status : t -> Ast.ident -> bool -> unit

    val set_struct_fields : t -> string -> (string * ty) list -> unit
    val get_struct_fields : t -> string -> (string * ty) list

end = struct
    type t = {
        type_env: (string, ty) Hashtbl.t;
        expr_env: (Ast.expr, ty) Hashtbl.t;
        escape_status: (Ast.ident, bool) Hashtbl.t;
        struct_fields_map: (string, (string * ty) list) Hashtbl.t;
    }

    let empty () = {
        type_env = Hashtbl.create 20;
        expr_env = Hashtbl.create 20;
        escape_status = Hashtbl.create 20;
        struct_fields_map = Hashtbl.create 20;
    }

    let get_named_type state name =
        Hashtbl.find (state.type_env) name

    let get_expr_type state expr = 
        Hashtbl.find (state.expr_env) expr

    let set_expr_type state expr ty =
        Hashtbl.add (state.expr_env) expr ty

    let get_escape_status state ident =
        Hashtbl.find (state.escape_status) ident

    let set_escape_status state ident escape =
        Hashtbl.add (state.escape_status) ident escape

    let set_struct_fields state name fields =
        Hashtbl.add state.struct_fields_map name fields

    let get_struct_fields state name =
        try Hashtbl.find state.struct_fields_map name
        with Not_found -> Util.raise_bug ("get_struct_fields failed to find fields for struct " ^ name)  
end